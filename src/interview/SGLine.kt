package interview

import java.util.*

object SGLine {
    object Test1 {
        /**
         * Description
        There are several ways to compress a string. One of them is as follows.

        When substring S appears K times in a given string, this can be represented as K(S).
        For example, if the string "hihihi" is given, this is represented as "3(hi)". Also, the string "hihihicohihihico" can be expressed as "2(3(hi)co)".

        Given a compressed string compressed, write a function solution to return the original string.

        Constraints
        Length of compressed is between 1 and 100.
        compressed is a string consists of number '0'~'9', parenthesis '(',')', and lower-case alphabet.
        compressed is a string generated by compressing the string of lower-case alphabet only.
        Therefore, the result of decompressing compressed is a string consists of the lower-case alphabet only.
        Given string is always compressed correctly.
        Length of string to return is between 1 and 1,000.
        Examples
        compressed	result
        "3(hi)"	"hihihi"
        "2(3(hi)co)"	"hihihicohihihico"
        "10(p)"	"pppppppppp"
        "2(2(hi)2(co))x2(bo)"	"hihicocohihicocoxbobo"
        Example #1
        It is the same as the example in the problem statement.

        Example #2
        It is the same as the example in the problem statement.

        Example #3
        The original string is a string where p appears consecutively 10 times.

        Example #4
        The original string of "2(2(hi)2(co))x2(bo)" is "hihicocohihicocoxbobo".
         */
        fun solution(compressed: String): String {
            var answer = ""
            var index = 0
            while (index != compressed.length) {
                if (compressed[index].isDigit()) {
                    var repeatNum = ""
                    while (compressed[index].isDigit()) {
                        repeatNum = "$repeatNum${compressed[index]}"
                        index++
                    }

                    if (compressed[index] == '(') {
                        // Characters within brackets
                        val stack = Stack<Char>()
                        stack.push('(')

                        var j = index + 1
                        while (!stack.empty()) {
                            if (compressed[j] == '(') stack.push('(')
                            if (compressed[j] == ')') stack.pop()
                            j++
                        }

                        answer = "$answer${solution(compressed.substring(index + 1, j - 1)).repeat(repeatNum.toInt())}"
                        index = j
                    }
                } else {
                    answer = "$answer${compressed[index]}"
                    index++
                }
            }

            return answer
        }
    }

    object Test2 {
        /**
         * Description
        Given an array A length of N, create a function that returns the appropriate interval length that satisfies the following conditions:

        The sum of all the elements within the interval must be greater than or equal to S.
        You must return the shortest interval length that meets the above condition.
        Constraints
        The number of elements : a natural number less than or equal to 100,000.
        Element : a natural number less than or equal to 10,000.
        S : a natural number and 1 ≦ S ≦ 1,000,000,000
        If there is no interval length which meets the above condition, then return 0.
        Examples
        A	S	return
        [1,10,2,9,3,8,4,7,5,6]	20	3
        Example #1
        Since the sum of the interval from the 2nd element through the 4th element, [10,2,9], is larger than 20, and the sum of the interval from the 4th element through the 6th element, [9,3,8], is 20, the length of the shortest interval satisfying the conditions is 3.
         */

        fun solution(A: IntArray, S: Int): Int {
            var minLength: Int = -1
            var currentSum = 0
            var startIndex = 0
            var endIndex = 0
            while (endIndex < A.size) {
                while (currentSum <= S && endIndex < A.size) currentSum += A[endIndex++]
                while (currentSum > S && startIndex < A.size) {
                    if (minLength == -1 || endIndex - startIndex < minLength) minLength = endIndex - startIndex
                    currentSum -= A[startIndex++]
                }
            }
            return if (minLength == -1) 0 else minLength
        }
    }

    object Test3 {
        /**
         * Macaron Crush is a game where you drop colored macarons from top to bottomone by one on a 6 x 6 board. When the macarons on the board make a match of three or more of the same color—either vertically or horizontally—they will pop. These macarons leave no empty space in between, and stack from the bottom. When they pop, macarons on top of them will drop to the below one by one. When that makes a match of three or more macarons of the same color, they will cause a chain reaction, and they will keep popping until there is no more match of three or more macarons of the same color. If there are more than one match of three or more macarons of the same color at any point, they will all pop at the same time.

        In the beginning, the board is completely empty. Suppose the following examples:

        1.
        Here is the order in which you drop macarons of different colors: Column 1 → Column 2 → Column 1 → Column 3 → Column 6 → Column 3. The board will look like the following:

        macaron_11.png

        2.
        The order in which you drop macarons is as follows: Column 3 → Column 3 → Column 3. The board will look like the following:

        macaron_12.png

        3.
        If you drop a pink macaron in Column 2, you can pop four macarons marked with 'X' as follows:

        macaron_13.png

        4.
        Once the pink macarons are gone, the remaining macarons will drop to the bottom. Here, the three purple macarons marked with X will pop.

        macaron_14.png

        5.
        When the rest of the macarons drop to the bottom, the board will look like the following:
        maracon_15.png

        Suppose a parameter macaron is given, where macaron is a two-dimensional array containing information of the moves made in the game. Please write a function solution that returns a string that represents what the board will look like once all the moves were made.

        Constraints
        The length of each column in macaron is between 1 and 100, and that of each row is 2.
        Each column of macaron is in the form of [macaron drop location, macaron color].
        The macaron drop location is a natural number between 1 and 6.
        The macaron color is represented as a natural number from 1 to 9. The macarons of the same color are displayed in the same number.
        Macarons don't fall outside of the board. They also don't stack anymore once they reach the maximum height.
        Make sure your function returns six strings whose lengths are 6.
        The first element of the array to be returned is the top row of the board, the second element the second row from the top, and so on.
        0 is an empty tile. A tile occupied by a macaron must be indicated by the number that represents the macaron color.
        Examples
        macaron	result
        [[1,1],[2,1],[1,2],[3,3],[6,4],[3,1],[3,3],[3,3],[3,4],[2,1]]	["000000","000000","000000","000000","000000","204004"]
        [[1,1],[1,2],[1,4],[2,1],[2,2],[2,3],[3,4],[3,1],[3,2],[3,3],[3,4],[4,4],[4,3],[5,4],[6,1]]	["000000","000000","000000","000000","000000","404001"]
        Example #1
        Demonstrated in the prompt above.

        Example #2

        1.
        Drop a macaron of Color 4 in Column 5 to start a chain.

        macaron_101.png

        2.
        macaron_102.png

        3.
        When the matches of three or more macarons of the same color pop at the same time, the rest will drop to the bottom. When macarons of Color 1, macarons of Color 2, and macarons of Color 3 pop at the same time (marked with 'X' below), the rest drop to the bottom.

        macaron_103.png

        4.
        Macarons of Color 3 pop, and you drop a macaron of Color 1 in Column 6.

        macaron_105.png

        5.
        In the end, the board will look like the following:

        macaron_106.png
         */
        fun solution(macaron: Array<IntArray>): Array<String> {
            var answer = arrayOf<String>("000000", "000000", "000000", "000000", "000000", "000000")

            macaron.forEach {
                val columnLocation = it[0] - 1
                val color = Character.forDigit(it[1], 10)

                var rowLocation = 0
                while (answer[5 - rowLocation][columnLocation] != '0') {
                    rowLocation++
                }

                answer[5 - rowLocation] = StringBuilder(answer[5 - rowLocation])
                    .also { s -> s.setCharAt(columnLocation, color) }
                    .toString()
            }

            for (i in 0..5) {
                for (j in 0..5) {
                    if (answer[i][j] != '0') {
                        val color = answer[i][j]
                        val temp = mutableListOf<IntArray>()

                        if (i < 5) {
                            for (m in i + 1..5) {
                                if (answer[m][j] == color) {
                                    temp.add(intArrayOf(m, j))
                                }
                            }
                        }

                        if (j < 5) {
                            for (m in j + 1..5) {
                                if (answer[i][m] == color) {
                                    temp.add(intArrayOf(i, m))
                                }
                            }
                        }
                    }
                }
            }

            return answer
        }
    }
}

fun main() {
//    print(SGLine.Test1.solution(compressed = "10(p)"))
//    print(SGLine.Test2.solution(A = intArrayOf(1, 10, 2, 9, 3, 8, 4, 7, 5, 6), S = 20))
    print(
        SGLine.Test3.solution(
            macaron = arrayOf(
                intArrayOf(1, 1),
                intArrayOf(2, 1),
                intArrayOf(1, 2),
                intArrayOf(3, 3),
                intArrayOf(6, 4),
                intArrayOf(3, 1),
                intArrayOf(3, 3),
                intArrayOf(3, 3),
                intArrayOf(3, 4),
                intArrayOf(2, 1),
            )
        )
            .toList().toString()
    )
}
